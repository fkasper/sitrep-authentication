// THIS FILE WAS AUTOGENERATED - ANY EDITS TO THIS WILL BE LOST WHEN IT IS REGENERATED
// GENERATED USING KEYSPACE sitrep
// AT 2016-02-01 07:17:19.731645203 +0100 CET USING cqlc VERSION 0.10.5
// AGAINST HOST ID 7b6304b7-a8d3-40a1-ba20-65197ce686fb (SERVER VERSION 2.2.2)
// CLIENT NEGOTIATED CQL VERSION 3.0.0 (SERVER SUPPORTS UP TO 3.3.1)

package sitrep

import (
	"github.com/gocql/gocql"

	"time"

	"github.com/relops/cqlc/cqlc"

	"log"
)

const (
	CQLC_VERSION = "0.10.5"
)

type CreateUsersInExerciseEmailColumn struct {
}

func (b *CreateUsersInExerciseEmailColumn) ColumnName() string {
	return "email"
}

func (b *CreateUsersInExerciseEmailColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *CreateUsersInExerciseEmailColumn) Eq(value string) cqlc.Condition {
	column := &CreateUsersInExerciseEmailColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *CreateUsersInExerciseEmailColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *CreateUsersInExerciseEmailColumn) In(value ...string) cqlc.Condition {
	column := &CreateUsersInExerciseEmailColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type CreateUsersInExerciseExercisesColumn struct {
}

func (b *CreateUsersInExerciseExercisesColumn) ColumnName() string {
	return "exercises"
}

func (b *CreateUsersInExerciseExercisesColumn) To(value *map[string]string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type CreateUsersInExercise struct {
	Email string

	Exercises map[string]string
}

func (s *CreateUsersInExercise) EmailValue() string {
	return s.Email
}

func (s *CreateUsersInExercise) ExercisesValue() map[string]string {
	return s.Exercises
}

type CreateUsersInExerciseDef struct {
	EMAIL cqlc.LastPartitionedStringColumn

	EXERCISES cqlc.StringStringMapColumn
}

func BindCreateUsersInExercise(iter *gocql.Iter) ([]CreateUsersInExercise, error) {
	array := make([]CreateUsersInExercise, 0)
	err := MapCreateUsersInExercise(iter, func(t CreateUsersInExercise) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapCreateUsersInExercise(iter *gocql.Iter, callback func(t CreateUsersInExercise) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := CreateUsersInExercise{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "email":
				row[i] = &t.Email

			case "exercises":
				row[i] = &t.Exercises

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *CreateUsersInExerciseDef) SupportsUpsert() bool {
	return true
}

func (s *CreateUsersInExerciseDef) TableName() string {
	return "create_users_in_exercise"
}

func (s *CreateUsersInExerciseDef) Keyspace() string {
	return "sitrep"
}

func (s *CreateUsersInExerciseDef) Bind(v CreateUsersInExercise) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &CreateUsersInExerciseEmailColumn{}, Value: v.Email},

		cqlc.ColumnBinding{Column: &CreateUsersInExerciseExercisesColumn{}, Value: v.Exercises},
	}
	return cqlc.TableBinding{Table: &CreateUsersInExerciseDef{}, Columns: cols}
}

func (s *CreateUsersInExerciseDef) To(v *CreateUsersInExercise) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &CreateUsersInExerciseEmailColumn{}, Value: &v.Email},

		cqlc.ColumnBinding{Column: &CreateUsersInExerciseExercisesColumn{}, Value: &v.Exercises},
	}
	return cqlc.TableBinding{Table: &CreateUsersInExerciseDef{}, Columns: cols}
}

func (s *CreateUsersInExerciseDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&CreateUsersInExerciseEmailColumn{},

		&CreateUsersInExerciseExercisesColumn{},
	}
}

func CreateUsersInExerciseTableDef() *CreateUsersInExerciseDef {
	return &CreateUsersInExerciseDef{

		EMAIL: &CreateUsersInExerciseEmailColumn{},

		EXERCISES: &CreateUsersInExerciseExercisesColumn{},
	}
}

func (s *CreateUsersInExerciseDef) EmailColumn() cqlc.LastPartitionedStringColumn {
	return &CreateUsersInExerciseEmailColumn{}
}

func (s *CreateUsersInExerciseDef) ExercisesColumn() cqlc.StringStringMapColumn {
	return &CreateUsersInExerciseExercisesColumn{}
}

type ExerciseByIdentifierActiveUntilColumn struct {
}

func (b *ExerciseByIdentifierActiveUntilColumn) ColumnName() string {
	return "active_until"
}

func (b *ExerciseByIdentifierActiveUntilColumn) To(value *time.Time) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierExerciseDescriptionColumn struct {
}

func (b *ExerciseByIdentifierExerciseDescriptionColumn) ColumnName() string {
	return "exercise_description"
}

func (b *ExerciseByIdentifierExerciseDescriptionColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierExerciseNameColumn struct {
}

func (b *ExerciseByIdentifierExerciseNameColumn) ColumnName() string {
	return "exercise_name"
}

func (b *ExerciseByIdentifierExerciseNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierHasActivationColumn struct {
}

func (b *ExerciseByIdentifierHasActivationColumn) ColumnName() string {
	return "has_activation"
}

func (b *ExerciseByIdentifierHasActivationColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierIdColumn struct {
}

func (b *ExerciseByIdentifierIdColumn) ColumnName() string {
	return "id"
}

func (b *ExerciseByIdentifierIdColumn) To(value *gocql.UUID) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *ExerciseByIdentifierIdColumn) Eq(value gocql.UUID) cqlc.Condition {
	column := &ExerciseByIdentifierIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *ExerciseByIdentifierIdColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *ExerciseByIdentifierIdColumn) In(value ...gocql.UUID) cqlc.Condition {
	column := &ExerciseByIdentifierIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type ExerciseByIdentifierIsActiveColumn struct {
}

func (b *ExerciseByIdentifierIsActiveColumn) ColumnName() string {
	return "is_active"
}

func (b *ExerciseByIdentifierIsActiveColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifier struct {
	ActiveUntil time.Time

	ExerciseDescription string

	ExerciseName string

	HasActivation bool

	Id gocql.UUID

	IsActive bool
}

func (s *ExerciseByIdentifier) ActiveUntilValue() time.Time {
	return s.ActiveUntil
}

func (s *ExerciseByIdentifier) ExerciseDescriptionValue() string {
	return s.ExerciseDescription
}

func (s *ExerciseByIdentifier) ExerciseNameValue() string {
	return s.ExerciseName
}

func (s *ExerciseByIdentifier) HasActivationValue() bool {
	return s.HasActivation
}

func (s *ExerciseByIdentifier) IdValue() gocql.UUID {
	return s.Id
}

func (s *ExerciseByIdentifier) IsActiveValue() bool {
	return s.IsActive
}

type ExerciseByIdentifierDef struct {
	ACTIVE_UNTIL cqlc.TimestampColumn

	EXERCISE_DESCRIPTION cqlc.StringColumn

	EXERCISE_NAME cqlc.StringColumn

	HAS_ACTIVATION cqlc.BooleanColumn

	ID cqlc.LastPartitionedUUIDColumn

	IS_ACTIVE cqlc.BooleanColumn
}

func BindExerciseByIdentifier(iter *gocql.Iter) ([]ExerciseByIdentifier, error) {
	array := make([]ExerciseByIdentifier, 0)
	err := MapExerciseByIdentifier(iter, func(t ExerciseByIdentifier) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapExerciseByIdentifier(iter *gocql.Iter, callback func(t ExerciseByIdentifier) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := ExerciseByIdentifier{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "active_until":
				row[i] = &t.ActiveUntil

			case "exercise_description":
				row[i] = &t.ExerciseDescription

			case "exercise_name":
				row[i] = &t.ExerciseName

			case "has_activation":
				row[i] = &t.HasActivation

			case "id":
				row[i] = &t.Id

			case "is_active":
				row[i] = &t.IsActive

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *ExerciseByIdentifierDef) SupportsUpsert() bool {
	return true
}

func (s *ExerciseByIdentifierDef) TableName() string {
	return "exercise_by_identifier"
}

func (s *ExerciseByIdentifierDef) Keyspace() string {
	return "sitrep"
}

func (s *ExerciseByIdentifierDef) Bind(v ExerciseByIdentifier) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierActiveUntilColumn{}, Value: v.ActiveUntil},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierExerciseDescriptionColumn{}, Value: v.ExerciseDescription},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierExerciseNameColumn{}, Value: v.ExerciseName},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierHasActivationColumn{}, Value: v.HasActivation},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierIdColumn{}, Value: v.Id},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierIsActiveColumn{}, Value: v.IsActive},
	}
	return cqlc.TableBinding{Table: &ExerciseByIdentifierDef{}, Columns: cols}
}

func (s *ExerciseByIdentifierDef) To(v *ExerciseByIdentifier) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierActiveUntilColumn{}, Value: &v.ActiveUntil},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierExerciseDescriptionColumn{}, Value: &v.ExerciseDescription},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierExerciseNameColumn{}, Value: &v.ExerciseName},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierHasActivationColumn{}, Value: &v.HasActivation},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierIdColumn{}, Value: &v.Id},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierIsActiveColumn{}, Value: &v.IsActive},
	}
	return cqlc.TableBinding{Table: &ExerciseByIdentifierDef{}, Columns: cols}
}

func (s *ExerciseByIdentifierDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&ExerciseByIdentifierActiveUntilColumn{},

		&ExerciseByIdentifierExerciseDescriptionColumn{},

		&ExerciseByIdentifierExerciseNameColumn{},

		&ExerciseByIdentifierHasActivationColumn{},

		&ExerciseByIdentifierIdColumn{},

		&ExerciseByIdentifierIsActiveColumn{},
	}
}

func ExerciseByIdentifierTableDef() *ExerciseByIdentifierDef {
	return &ExerciseByIdentifierDef{

		ACTIVE_UNTIL: &ExerciseByIdentifierActiveUntilColumn{},

		EXERCISE_DESCRIPTION: &ExerciseByIdentifierExerciseDescriptionColumn{},

		EXERCISE_NAME: &ExerciseByIdentifierExerciseNameColumn{},

		HAS_ACTIVATION: &ExerciseByIdentifierHasActivationColumn{},

		ID: &ExerciseByIdentifierIdColumn{},

		IS_ACTIVE: &ExerciseByIdentifierIsActiveColumn{},
	}
}

func (s *ExerciseByIdentifierDef) ActiveUntilColumn() cqlc.TimestampColumn {
	return &ExerciseByIdentifierActiveUntilColumn{}
}

func (s *ExerciseByIdentifierDef) ExerciseDescriptionColumn() cqlc.StringColumn {
	return &ExerciseByIdentifierExerciseDescriptionColumn{}
}

func (s *ExerciseByIdentifierDef) ExerciseNameColumn() cqlc.StringColumn {
	return &ExerciseByIdentifierExerciseNameColumn{}
}

func (s *ExerciseByIdentifierDef) HasActivationColumn() cqlc.BooleanColumn {
	return &ExerciseByIdentifierHasActivationColumn{}
}

func (s *ExerciseByIdentifierDef) IdColumn() cqlc.LastPartitionedUUIDColumn {
	return &ExerciseByIdentifierIdColumn{}
}

func (s *ExerciseByIdentifierDef) IsActiveColumn() cqlc.BooleanColumn {
	return &ExerciseByIdentifierIsActiveColumn{}
}

type ExerciseByIdentifierAndEmailEmailColumn struct {
}

func (b *ExerciseByIdentifierAndEmailEmailColumn) ColumnName() string {
	return "email"
}

func (b *ExerciseByIdentifierAndEmailEmailColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierAndEmailExerciseNameColumn struct {
}

func (b *ExerciseByIdentifierAndEmailExerciseNameColumn) ColumnName() string {
	return "exercise_name"
}

func (b *ExerciseByIdentifierAndEmailExerciseNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierAndEmailIdColumn struct {
}

func (b *ExerciseByIdentifierAndEmailIdColumn) ColumnName() string {
	return "id"
}

func (b *ExerciseByIdentifierAndEmailIdColumn) To(value *gocql.UUID) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *ExerciseByIdentifierAndEmailIdColumn) Eq(value gocql.UUID) cqlc.Condition {
	column := &ExerciseByIdentifierAndEmailIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *ExerciseByIdentifierAndEmailIdColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *ExerciseByIdentifierAndEmailIdColumn) In(value ...gocql.UUID) cqlc.Condition {
	column := &ExerciseByIdentifierAndEmailIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type ExerciseByIdentifierAndEmailIsActiveColumn struct {
}

func (b *ExerciseByIdentifierAndEmailIsActiveColumn) ColumnName() string {
	return "is_active"
}

func (b *ExerciseByIdentifierAndEmailIsActiveColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierAndEmailIsAuthorizedColumn struct {
}

func (b *ExerciseByIdentifierAndEmailIsAuthorizedColumn) ColumnName() string {
	return "is_authorized"
}

func (b *ExerciseByIdentifierAndEmailIsAuthorizedColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierAndEmailIsOperatorColumn struct {
}

func (b *ExerciseByIdentifierAndEmailIsOperatorColumn) ColumnName() string {
	return "is_operator"
}

func (b *ExerciseByIdentifierAndEmailIsOperatorColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierAndEmailUserNameColumn struct {
}

func (b *ExerciseByIdentifierAndEmailUserNameColumn) ColumnName() string {
	return "user_name"
}

func (b *ExerciseByIdentifierAndEmailUserNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExerciseByIdentifierAndEmail struct {
	Email string

	ExerciseName string

	Id gocql.UUID

	IsActive bool

	IsAuthorized bool

	IsOperator bool

	UserName string
}

func (s *ExerciseByIdentifierAndEmail) EmailValue() string {
	return s.Email
}

func (s *ExerciseByIdentifierAndEmail) ExerciseNameValue() string {
	return s.ExerciseName
}

func (s *ExerciseByIdentifierAndEmail) IdValue() gocql.UUID {
	return s.Id
}

func (s *ExerciseByIdentifierAndEmail) IsActiveValue() bool {
	return s.IsActive
}

func (s *ExerciseByIdentifierAndEmail) IsAuthorizedValue() bool {
	return s.IsAuthorized
}

func (s *ExerciseByIdentifierAndEmail) IsOperatorValue() bool {
	return s.IsOperator
}

func (s *ExerciseByIdentifierAndEmail) UserNameValue() string {
	return s.UserName
}

type ExerciseByIdentifierAndEmailDef struct {
	EMAIL cqlc.StringColumn

	EXERCISE_NAME cqlc.StringColumn

	ID cqlc.LastPartitionedUUIDColumn

	IS_ACTIVE cqlc.BooleanColumn

	IS_AUTHORIZED cqlc.BooleanColumn

	IS_OPERATOR cqlc.BooleanColumn

	USER_NAME cqlc.StringColumn
}

func BindExerciseByIdentifierAndEmail(iter *gocql.Iter) ([]ExerciseByIdentifierAndEmail, error) {
	array := make([]ExerciseByIdentifierAndEmail, 0)
	err := MapExerciseByIdentifierAndEmail(iter, func(t ExerciseByIdentifierAndEmail) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapExerciseByIdentifierAndEmail(iter *gocql.Iter, callback func(t ExerciseByIdentifierAndEmail) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := ExerciseByIdentifierAndEmail{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "email":
				row[i] = &t.Email

			case "exercise_name":
				row[i] = &t.ExerciseName

			case "id":
				row[i] = &t.Id

			case "is_active":
				row[i] = &t.IsActive

			case "is_authorized":
				row[i] = &t.IsAuthorized

			case "is_operator":
				row[i] = &t.IsOperator

			case "user_name":
				row[i] = &t.UserName

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *ExerciseByIdentifierAndEmailDef) SupportsUpsert() bool {
	return true
}

func (s *ExerciseByIdentifierAndEmailDef) TableName() string {
	return "exercise_by_identifier_and_email"
}

func (s *ExerciseByIdentifierAndEmailDef) Keyspace() string {
	return "sitrep"
}

func (s *ExerciseByIdentifierAndEmailDef) Bind(v ExerciseByIdentifierAndEmail) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailEmailColumn{}, Value: v.Email},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailExerciseNameColumn{}, Value: v.ExerciseName},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIdColumn{}, Value: v.Id},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIsActiveColumn{}, Value: v.IsActive},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIsAuthorizedColumn{}, Value: v.IsAuthorized},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIsOperatorColumn{}, Value: v.IsOperator},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailUserNameColumn{}, Value: v.UserName},
	}
	return cqlc.TableBinding{Table: &ExerciseByIdentifierAndEmailDef{}, Columns: cols}
}

func (s *ExerciseByIdentifierAndEmailDef) To(v *ExerciseByIdentifierAndEmail) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailEmailColumn{}, Value: &v.Email},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailExerciseNameColumn{}, Value: &v.ExerciseName},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIdColumn{}, Value: &v.Id},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIsActiveColumn{}, Value: &v.IsActive},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIsAuthorizedColumn{}, Value: &v.IsAuthorized},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailIsOperatorColumn{}, Value: &v.IsOperator},

		cqlc.ColumnBinding{Column: &ExerciseByIdentifierAndEmailUserNameColumn{}, Value: &v.UserName},
	}
	return cqlc.TableBinding{Table: &ExerciseByIdentifierAndEmailDef{}, Columns: cols}
}

func (s *ExerciseByIdentifierAndEmailDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&ExerciseByIdentifierAndEmailEmailColumn{},

		&ExerciseByIdentifierAndEmailExerciseNameColumn{},

		&ExerciseByIdentifierAndEmailIdColumn{},

		&ExerciseByIdentifierAndEmailIsActiveColumn{},

		&ExerciseByIdentifierAndEmailIsAuthorizedColumn{},

		&ExerciseByIdentifierAndEmailIsOperatorColumn{},

		&ExerciseByIdentifierAndEmailUserNameColumn{},
	}
}

func ExerciseByIdentifierAndEmailTableDef() *ExerciseByIdentifierAndEmailDef {
	return &ExerciseByIdentifierAndEmailDef{

		EMAIL: &ExerciseByIdentifierAndEmailEmailColumn{},

		EXERCISE_NAME: &ExerciseByIdentifierAndEmailExerciseNameColumn{},

		ID: &ExerciseByIdentifierAndEmailIdColumn{},

		IS_ACTIVE: &ExerciseByIdentifierAndEmailIsActiveColumn{},

		IS_AUTHORIZED: &ExerciseByIdentifierAndEmailIsAuthorizedColumn{},

		IS_OPERATOR: &ExerciseByIdentifierAndEmailIsOperatorColumn{},

		USER_NAME: &ExerciseByIdentifierAndEmailUserNameColumn{},
	}
}

func (s *ExerciseByIdentifierAndEmailDef) EmailColumn() cqlc.StringColumn {
	return &ExerciseByIdentifierAndEmailEmailColumn{}
}

func (s *ExerciseByIdentifierAndEmailDef) ExerciseNameColumn() cqlc.StringColumn {
	return &ExerciseByIdentifierAndEmailExerciseNameColumn{}
}

func (s *ExerciseByIdentifierAndEmailDef) IdColumn() cqlc.LastPartitionedUUIDColumn {
	return &ExerciseByIdentifierAndEmailIdColumn{}
}

func (s *ExerciseByIdentifierAndEmailDef) IsActiveColumn() cqlc.BooleanColumn {
	return &ExerciseByIdentifierAndEmailIsActiveColumn{}
}

func (s *ExerciseByIdentifierAndEmailDef) IsAuthorizedColumn() cqlc.BooleanColumn {
	return &ExerciseByIdentifierAndEmailIsAuthorizedColumn{}
}

func (s *ExerciseByIdentifierAndEmailDef) IsOperatorColumn() cqlc.BooleanColumn {
	return &ExerciseByIdentifierAndEmailIsOperatorColumn{}
}

func (s *ExerciseByIdentifierAndEmailDef) UserNameColumn() cqlc.StringColumn {
	return &ExerciseByIdentifierAndEmailUserNameColumn{}
}

type ExercisePermissionsLevelExerciseIdentifierColumn struct {
	desc bool
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) ColumnName() string {
	return "exercise_identifier"
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) To(value *gocql.UUID) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) ClusterWith() string {
	return b.ColumnName()
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) Desc() cqlc.ClusteredColumn {
	return &ExercisePermissionsLevelExerciseIdentifierColumn{desc: true}
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) IsDescending() bool {
	return b.desc
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) Eq(value gocql.UUID) cqlc.Condition {
	column := &ExercisePermissionsLevelExerciseIdentifierColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) In(value ...gocql.UUID) cqlc.Condition {
	column := &ExercisePermissionsLevelExerciseIdentifierColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

func (b *ExercisePermissionsLevelExerciseIdentifierColumn) Gt(value gocql.UUID) cqlc.Condition {
	column := &ExercisePermissionsLevelExerciseIdentifierColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.GtPredicate}
}
func (b *ExercisePermissionsLevelExerciseIdentifierColumn) Ge(value gocql.UUID) cqlc.Condition {
	column := &ExercisePermissionsLevelExerciseIdentifierColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.GePredicate}
}
func (b *ExercisePermissionsLevelExerciseIdentifierColumn) Lt(value gocql.UUID) cqlc.Condition {
	column := &ExercisePermissionsLevelExerciseIdentifierColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.LtPredicate}
}
func (b *ExercisePermissionsLevelExerciseIdentifierColumn) Le(value gocql.UUID) cqlc.Condition {
	column := &ExercisePermissionsLevelExerciseIdentifierColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.LePredicate}
}

type ExercisePermissionsLevelIsAdminColumn struct {
}

func (b *ExercisePermissionsLevelIsAdminColumn) ColumnName() string {
	return "is_admin"
}

func (b *ExercisePermissionsLevelIsAdminColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExercisePermissionsLevelIsAuthorizedColumn struct {
}

func (b *ExercisePermissionsLevelIsAuthorizedColumn) ColumnName() string {
	return "is_authorized"
}

func (b *ExercisePermissionsLevelIsAuthorizedColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExercisePermissionsLevelIsInvisibleColumn struct {
}

func (b *ExercisePermissionsLevelIsInvisibleColumn) ColumnName() string {
	return "is_invisible"
}

func (b *ExercisePermissionsLevelIsInvisibleColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExercisePermissionsLevelIsOcColumn struct {
}

func (b *ExercisePermissionsLevelIsOcColumn) ColumnName() string {
	return "is_oc"
}

func (b *ExercisePermissionsLevelIsOcColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExercisePermissionsLevelIsTraineeColumn struct {
}

func (b *ExercisePermissionsLevelIsTraineeColumn) ColumnName() string {
	return "is_trainee"
}

func (b *ExercisePermissionsLevelIsTraineeColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExercisePermissionsLevelRoleDescriptionColumn struct {
}

func (b *ExercisePermissionsLevelRoleDescriptionColumn) ColumnName() string {
	return "role_description"
}

func (b *ExercisePermissionsLevelRoleDescriptionColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type ExercisePermissionsLevelUserEmailColumn struct {
}

func (b *ExercisePermissionsLevelUserEmailColumn) ColumnName() string {
	return "user_email"
}

func (b *ExercisePermissionsLevelUserEmailColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *ExercisePermissionsLevelUserEmailColumn) Eq(value string) cqlc.Condition {
	column := &ExercisePermissionsLevelUserEmailColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *ExercisePermissionsLevelUserEmailColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *ExercisePermissionsLevelUserEmailColumn) In(value ...string) cqlc.Condition {
	column := &ExercisePermissionsLevelUserEmailColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type ExercisePermissionsLevel struct {
	ExerciseIdentifier gocql.UUID

	IsAdmin bool

	IsAuthorized bool

	IsInvisible bool

	IsOc bool

	IsTrainee bool

	RoleDescription string

	UserEmail string
}

func (s *ExercisePermissionsLevel) ExerciseIdentifierValue() gocql.UUID {
	return s.ExerciseIdentifier
}

func (s *ExercisePermissionsLevel) IsAdminValue() bool {
	return s.IsAdmin
}

func (s *ExercisePermissionsLevel) IsAuthorizedValue() bool {
	return s.IsAuthorized
}

func (s *ExercisePermissionsLevel) IsInvisibleValue() bool {
	return s.IsInvisible
}

func (s *ExercisePermissionsLevel) IsOcValue() bool {
	return s.IsOc
}

func (s *ExercisePermissionsLevel) IsTraineeValue() bool {
	return s.IsTrainee
}

func (s *ExercisePermissionsLevel) RoleDescriptionValue() string {
	return s.RoleDescription
}

func (s *ExercisePermissionsLevel) UserEmailValue() string {
	return s.UserEmail
}

type ExercisePermissionsLevelDef struct {
	EXERCISE_IDENTIFIER cqlc.LastClusteredUUIDColumn

	IS_ADMIN cqlc.BooleanColumn

	IS_AUTHORIZED cqlc.BooleanColumn

	IS_INVISIBLE cqlc.BooleanColumn

	IS_OC cqlc.BooleanColumn

	IS_TRAINEE cqlc.BooleanColumn

	ROLE_DESCRIPTION cqlc.StringColumn

	USER_EMAIL cqlc.LastPartitionedStringColumn
}

func BindExercisePermissionsLevel(iter *gocql.Iter) ([]ExercisePermissionsLevel, error) {
	array := make([]ExercisePermissionsLevel, 0)
	err := MapExercisePermissionsLevel(iter, func(t ExercisePermissionsLevel) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapExercisePermissionsLevel(iter *gocql.Iter, callback func(t ExercisePermissionsLevel) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := ExercisePermissionsLevel{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "exercise_identifier":
				row[i] = &t.ExerciseIdentifier

			case "is_admin":
				row[i] = &t.IsAdmin

			case "is_authorized":
				row[i] = &t.IsAuthorized

			case "is_invisible":
				row[i] = &t.IsInvisible

			case "is_oc":
				row[i] = &t.IsOc

			case "is_trainee":
				row[i] = &t.IsTrainee

			case "role_description":
				row[i] = &t.RoleDescription

			case "user_email":
				row[i] = &t.UserEmail

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *ExercisePermissionsLevelDef) SupportsUpsert() bool {
	return true
}

func (s *ExercisePermissionsLevelDef) TableName() string {
	return "exercise_permissions_level"
}

func (s *ExercisePermissionsLevelDef) Keyspace() string {
	return "sitrep"
}

func (s *ExercisePermissionsLevelDef) Bind(v ExercisePermissionsLevel) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelExerciseIdentifierColumn{}, Value: v.ExerciseIdentifier},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsAdminColumn{}, Value: v.IsAdmin},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsAuthorizedColumn{}, Value: v.IsAuthorized},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsInvisibleColumn{}, Value: v.IsInvisible},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsOcColumn{}, Value: v.IsOc},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsTraineeColumn{}, Value: v.IsTrainee},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelRoleDescriptionColumn{}, Value: v.RoleDescription},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelUserEmailColumn{}, Value: v.UserEmail},
	}
	return cqlc.TableBinding{Table: &ExercisePermissionsLevelDef{}, Columns: cols}
}

func (s *ExercisePermissionsLevelDef) To(v *ExercisePermissionsLevel) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelExerciseIdentifierColumn{}, Value: &v.ExerciseIdentifier},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsAdminColumn{}, Value: &v.IsAdmin},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsAuthorizedColumn{}, Value: &v.IsAuthorized},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsInvisibleColumn{}, Value: &v.IsInvisible},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsOcColumn{}, Value: &v.IsOc},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelIsTraineeColumn{}, Value: &v.IsTrainee},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelRoleDescriptionColumn{}, Value: &v.RoleDescription},

		cqlc.ColumnBinding{Column: &ExercisePermissionsLevelUserEmailColumn{}, Value: &v.UserEmail},
	}
	return cqlc.TableBinding{Table: &ExercisePermissionsLevelDef{}, Columns: cols}
}

func (s *ExercisePermissionsLevelDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&ExercisePermissionsLevelExerciseIdentifierColumn{},

		&ExercisePermissionsLevelIsAdminColumn{},

		&ExercisePermissionsLevelIsAuthorizedColumn{},

		&ExercisePermissionsLevelIsInvisibleColumn{},

		&ExercisePermissionsLevelIsOcColumn{},

		&ExercisePermissionsLevelIsTraineeColumn{},

		&ExercisePermissionsLevelRoleDescriptionColumn{},

		&ExercisePermissionsLevelUserEmailColumn{},
	}
}

func ExercisePermissionsLevelTableDef() *ExercisePermissionsLevelDef {
	return &ExercisePermissionsLevelDef{

		EXERCISE_IDENTIFIER: &ExercisePermissionsLevelExerciseIdentifierColumn{},

		IS_ADMIN: &ExercisePermissionsLevelIsAdminColumn{},

		IS_AUTHORIZED: &ExercisePermissionsLevelIsAuthorizedColumn{},

		IS_INVISIBLE: &ExercisePermissionsLevelIsInvisibleColumn{},

		IS_OC: &ExercisePermissionsLevelIsOcColumn{},

		IS_TRAINEE: &ExercisePermissionsLevelIsTraineeColumn{},

		ROLE_DESCRIPTION: &ExercisePermissionsLevelRoleDescriptionColumn{},

		USER_EMAIL: &ExercisePermissionsLevelUserEmailColumn{},
	}
}

func (s *ExercisePermissionsLevelDef) ExerciseIdentifierColumn() cqlc.LastClusteredUUIDColumn {
	return &ExercisePermissionsLevelExerciseIdentifierColumn{}
}

func (s *ExercisePermissionsLevelDef) IsAdminColumn() cqlc.BooleanColumn {
	return &ExercisePermissionsLevelIsAdminColumn{}
}

func (s *ExercisePermissionsLevelDef) IsAuthorizedColumn() cqlc.BooleanColumn {
	return &ExercisePermissionsLevelIsAuthorizedColumn{}
}

func (s *ExercisePermissionsLevelDef) IsInvisibleColumn() cqlc.BooleanColumn {
	return &ExercisePermissionsLevelIsInvisibleColumn{}
}

func (s *ExercisePermissionsLevelDef) IsOcColumn() cqlc.BooleanColumn {
	return &ExercisePermissionsLevelIsOcColumn{}
}

func (s *ExercisePermissionsLevelDef) IsTraineeColumn() cqlc.BooleanColumn {
	return &ExercisePermissionsLevelIsTraineeColumn{}
}

func (s *ExercisePermissionsLevelDef) RoleDescriptionColumn() cqlc.StringColumn {
	return &ExercisePermissionsLevelRoleDescriptionColumn{}
}

func (s *ExercisePermissionsLevelDef) UserEmailColumn() cqlc.LastPartitionedStringColumn {
	return &ExercisePermissionsLevelUserEmailColumn{}
}

type SchemaMigrationsVersionColumn struct {
}

func (b *SchemaMigrationsVersionColumn) ColumnName() string {
	return "version"
}

func (b *SchemaMigrationsVersionColumn) To(value *int64) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *SchemaMigrationsVersionColumn) CanIncrement() bool {
	return true
}

type SchemaMigrationsVersionrowColumn struct {
}

func (b *SchemaMigrationsVersionrowColumn) ColumnName() string {
	return "versionrow"
}

func (b *SchemaMigrationsVersionrowColumn) To(value *int64) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *SchemaMigrationsVersionrowColumn) Eq(value int64) cqlc.Condition {
	column := &SchemaMigrationsVersionrowColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *SchemaMigrationsVersionrowColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *SchemaMigrationsVersionrowColumn) In(value ...int64) cqlc.Condition {
	column := &SchemaMigrationsVersionrowColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type SchemaMigrations struct {
	Version int64

	Versionrow int64
}

func (s *SchemaMigrations) VersionValue() int64 {
	return s.Version
}

func (s *SchemaMigrations) VersionrowValue() int64 {
	return s.Versionrow
}

type SchemaMigrationsDef struct {
	VERSION cqlc.CounterColumn

	VERSIONROW cqlc.LastPartitionedInt64Column
}

func BindSchemaMigrations(iter *gocql.Iter) ([]SchemaMigrations, error) {
	array := make([]SchemaMigrations, 0)
	err := MapSchemaMigrations(iter, func(t SchemaMigrations) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapSchemaMigrations(iter *gocql.Iter, callback func(t SchemaMigrations) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := SchemaMigrations{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "version":
				row[i] = &t.Version

			case "versionrow":
				row[i] = &t.Versionrow

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *SchemaMigrationsDef) IsCounterTable() bool {
	return true
}

func (s *SchemaMigrationsDef) TableName() string {
	return "schema_migrations"
}

func (s *SchemaMigrationsDef) Keyspace() string {
	return "sitrep"
}

func (s *SchemaMigrationsDef) Bind(v SchemaMigrations) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &SchemaMigrationsVersionColumn{}, Value: v.Version},

		cqlc.ColumnBinding{Column: &SchemaMigrationsVersionrowColumn{}, Value: v.Versionrow},
	}
	return cqlc.TableBinding{Table: &SchemaMigrationsDef{}, Columns: cols}
}

func (s *SchemaMigrationsDef) To(v *SchemaMigrations) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &SchemaMigrationsVersionColumn{}, Value: &v.Version},

		cqlc.ColumnBinding{Column: &SchemaMigrationsVersionrowColumn{}, Value: &v.Versionrow},
	}
	return cqlc.TableBinding{Table: &SchemaMigrationsDef{}, Columns: cols}
}

func (s *SchemaMigrationsDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&SchemaMigrationsVersionColumn{},

		&SchemaMigrationsVersionrowColumn{},
	}
}

func SchemaMigrationsTableDef() *SchemaMigrationsDef {
	return &SchemaMigrationsDef{

		VERSION: &SchemaMigrationsVersionColumn{},

		VERSIONROW: &SchemaMigrationsVersionrowColumn{},
	}
}

func (s *SchemaMigrationsDef) VersionColumn() cqlc.CounterColumn {
	return &SchemaMigrationsVersionColumn{}
}

func (s *SchemaMigrationsDef) VersionrowColumn() cqlc.LastPartitionedInt64Column {
	return &SchemaMigrationsVersionrowColumn{}
}

type SettingsByExerciseIdentifierIdColumn struct {
}

func (b *SettingsByExerciseIdentifierIdColumn) ColumnName() string {
	return "id"
}

func (b *SettingsByExerciseIdentifierIdColumn) To(value *gocql.UUID) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *SettingsByExerciseIdentifierIdColumn) Eq(value gocql.UUID) cqlc.Condition {
	column := &SettingsByExerciseIdentifierIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *SettingsByExerciseIdentifierIdColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *SettingsByExerciseIdentifierIdColumn) In(value ...gocql.UUID) cqlc.Condition {
	column := &SettingsByExerciseIdentifierIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type SettingsByExerciseIdentifierIsDefaultColumn struct {
}

func (b *SettingsByExerciseIdentifierIsDefaultColumn) ColumnName() string {
	return "is_default"
}

func (b *SettingsByExerciseIdentifierIsDefaultColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type SettingsByExerciseIdentifierSettingsColumn struct {
}

func (b *SettingsByExerciseIdentifierSettingsColumn) ColumnName() string {
	return "settings"
}

func (b *SettingsByExerciseIdentifierSettingsColumn) To(value *map[string]string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type SettingsByExerciseIdentifierSettingsVersionColumn struct {
}

func (b *SettingsByExerciseIdentifierSettingsVersionColumn) ColumnName() string {
	return "settings_version"
}

func (b *SettingsByExerciseIdentifierSettingsVersionColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type SettingsByExerciseIdentifier struct {
	Id gocql.UUID

	IsDefault bool

	Settings map[string]string

	SettingsVersion string
}

func (s *SettingsByExerciseIdentifier) IdValue() gocql.UUID {
	return s.Id
}

func (s *SettingsByExerciseIdentifier) IsDefaultValue() bool {
	return s.IsDefault
}

func (s *SettingsByExerciseIdentifier) SettingsValue() map[string]string {
	return s.Settings
}

func (s *SettingsByExerciseIdentifier) SettingsVersionValue() string {
	return s.SettingsVersion
}

type SettingsByExerciseIdentifierDef struct {
	ID cqlc.LastPartitionedUUIDColumn

	IS_DEFAULT cqlc.BooleanColumn

	SETTINGS cqlc.StringStringMapColumn

	SETTINGS_VERSION cqlc.StringColumn
}

func BindSettingsByExerciseIdentifier(iter *gocql.Iter) ([]SettingsByExerciseIdentifier, error) {
	array := make([]SettingsByExerciseIdentifier, 0)
	err := MapSettingsByExerciseIdentifier(iter, func(t SettingsByExerciseIdentifier) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapSettingsByExerciseIdentifier(iter *gocql.Iter, callback func(t SettingsByExerciseIdentifier) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := SettingsByExerciseIdentifier{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "id":
				row[i] = &t.Id

			case "is_default":
				row[i] = &t.IsDefault

			case "settings":
				row[i] = &t.Settings

			case "settings_version":
				row[i] = &t.SettingsVersion

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *SettingsByExerciseIdentifierDef) SupportsUpsert() bool {
	return true
}

func (s *SettingsByExerciseIdentifierDef) TableName() string {
	return "settings_by_exercise_identifier"
}

func (s *SettingsByExerciseIdentifierDef) Keyspace() string {
	return "sitrep"
}

func (s *SettingsByExerciseIdentifierDef) Bind(v SettingsByExerciseIdentifier) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierIdColumn{}, Value: v.Id},

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierIsDefaultColumn{}, Value: v.IsDefault},

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierSettingsColumn{}, Value: v.Settings},

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierSettingsVersionColumn{}, Value: v.SettingsVersion},
	}
	return cqlc.TableBinding{Table: &SettingsByExerciseIdentifierDef{}, Columns: cols}
}

func (s *SettingsByExerciseIdentifierDef) To(v *SettingsByExerciseIdentifier) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierIdColumn{}, Value: &v.Id},

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierIsDefaultColumn{}, Value: &v.IsDefault},

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierSettingsColumn{}, Value: &v.Settings},

		cqlc.ColumnBinding{Column: &SettingsByExerciseIdentifierSettingsVersionColumn{}, Value: &v.SettingsVersion},
	}
	return cqlc.TableBinding{Table: &SettingsByExerciseIdentifierDef{}, Columns: cols}
}

func (s *SettingsByExerciseIdentifierDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&SettingsByExerciseIdentifierIdColumn{},

		&SettingsByExerciseIdentifierIsDefaultColumn{},

		&SettingsByExerciseIdentifierSettingsColumn{},

		&SettingsByExerciseIdentifierSettingsVersionColumn{},
	}
}

func SettingsByExerciseIdentifierTableDef() *SettingsByExerciseIdentifierDef {
	return &SettingsByExerciseIdentifierDef{

		ID: &SettingsByExerciseIdentifierIdColumn{},

		IS_DEFAULT: &SettingsByExerciseIdentifierIsDefaultColumn{},

		SETTINGS: &SettingsByExerciseIdentifierSettingsColumn{},

		SETTINGS_VERSION: &SettingsByExerciseIdentifierSettingsVersionColumn{},
	}
}

func (s *SettingsByExerciseIdentifierDef) IdColumn() cqlc.LastPartitionedUUIDColumn {
	return &SettingsByExerciseIdentifierIdColumn{}
}

func (s *SettingsByExerciseIdentifierDef) IsDefaultColumn() cqlc.BooleanColumn {
	return &SettingsByExerciseIdentifierIsDefaultColumn{}
}

func (s *SettingsByExerciseIdentifierDef) SettingsColumn() cqlc.StringStringMapColumn {
	return &SettingsByExerciseIdentifierSettingsColumn{}
}

func (s *SettingsByExerciseIdentifierDef) SettingsVersionColumn() cqlc.StringColumn {
	return &SettingsByExerciseIdentifierSettingsVersionColumn{}
}

type UsersByEmailAccessValidTillColumn struct {
}

func (b *UsersByEmailAccessValidTillColumn) ColumnName() string {
	return "access_valid_till"
}

func (b *UsersByEmailAccessValidTillColumn) To(value *time.Time) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailAnalyticsUserTrackingTokenColumn struct {
}

func (b *UsersByEmailAnalyticsUserTrackingTokenColumn) ColumnName() string {
	return "analytics_user_tracking_token"
}

func (b *UsersByEmailAnalyticsUserTrackingTokenColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailEmailColumn struct {
}

func (b *UsersByEmailEmailColumn) ColumnName() string {
	return "email"
}

func (b *UsersByEmailEmailColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *UsersByEmailEmailColumn) Eq(value string) cqlc.Condition {
	column := &UsersByEmailEmailColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *UsersByEmailEmailColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *UsersByEmailEmailColumn) In(value ...string) cqlc.Condition {
	column := &UsersByEmailEmailColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type UsersByEmailEncryptedPasswordColumn struct {
}

func (b *UsersByEmailEncryptedPasswordColumn) ColumnName() string {
	return "encrypted_password"
}

func (b *UsersByEmailEncryptedPasswordColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailIsAdminColumn struct {
}

func (b *UsersByEmailIsAdminColumn) ColumnName() string {
	return "is_admin"
}

func (b *UsersByEmailIsAdminColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailIsAnalyzedColumn struct {
}

func (b *UsersByEmailIsAnalyzedColumn) ColumnName() string {
	return "is_analyzed"
}

func (b *UsersByEmailIsAnalyzedColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailIsBannedColumn struct {
}

func (b *UsersByEmailIsBannedColumn) ColumnName() string {
	return "is_banned"
}

func (b *UsersByEmailIsBannedColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailIsConfirmedColumn struct {
}

func (b *UsersByEmailIsConfirmedColumn) ColumnName() string {
	return "is_confirmed"
}

func (b *UsersByEmailIsConfirmedColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailIsEmployeeColumn struct {
}

func (b *UsersByEmailIsEmployeeColumn) ColumnName() string {
	return "is_employee"
}

func (b *UsersByEmailIsEmployeeColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailIsExpiringColumn struct {
}

func (b *UsersByEmailIsExpiringColumn) ColumnName() string {
	return "is_expiring"
}

func (b *UsersByEmailIsExpiringColumn) To(value *bool) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailJwtEncryptionKeyColumn struct {
}

func (b *UsersByEmailJwtEncryptionKeyColumn) ColumnName() string {
	return "jwt_encryption_key"
}

func (b *UsersByEmailJwtEncryptionKeyColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailLastLoggedInColumn struct {
}

func (b *UsersByEmailLastLoggedInColumn) ColumnName() string {
	return "last_logged_in"
}

func (b *UsersByEmailLastLoggedInColumn) To(value *time.Time) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailRealNameColumn struct {
}

func (b *UsersByEmailRealNameColumn) ColumnName() string {
	return "real_name"
}

func (b *UsersByEmailRealNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailTwitterNameColumn struct {
}

func (b *UsersByEmailTwitterNameColumn) ColumnName() string {
	return "twitter_name"
}

func (b *UsersByEmailTwitterNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailUserRankColumn struct {
}

func (b *UsersByEmailUserRankColumn) ColumnName() string {
	return "user_rank"
}

func (b *UsersByEmailUserRankColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailUserSelfDescriptionColumn struct {
}

func (b *UsersByEmailUserSelfDescriptionColumn) ColumnName() string {
	return "user_self_description"
}

func (b *UsersByEmailUserSelfDescriptionColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailUserTitleColumn struct {
}

func (b *UsersByEmailUserTitleColumn) ColumnName() string {
	return "user_title"
}

func (b *UsersByEmailUserTitleColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmailUserUnitColumn struct {
}

func (b *UsersByEmailUserUnitColumn) ColumnName() string {
	return "user_unit"
}

func (b *UsersByEmailUserUnitColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByEmail struct {
	AccessValidTill time.Time

	AnalyticsUserTrackingToken string

	Email string

	EncryptedPassword string

	IsAdmin bool

	IsAnalyzed bool

	IsBanned bool

	IsConfirmed bool

	IsEmployee bool

	IsExpiring bool

	JwtEncryptionKey string

	LastLoggedIn time.Time

	RealName string

	TwitterName string

	UserRank string

	UserSelfDescription string

	UserTitle string

	UserUnit string
}

func (s *UsersByEmail) AccessValidTillValue() time.Time {
	return s.AccessValidTill
}

func (s *UsersByEmail) AnalyticsUserTrackingTokenValue() string {
	return s.AnalyticsUserTrackingToken
}

func (s *UsersByEmail) EmailValue() string {
	return s.Email
}

func (s *UsersByEmail) EncryptedPasswordValue() string {
	return s.EncryptedPassword
}

func (s *UsersByEmail) IsAdminValue() bool {
	return s.IsAdmin
}

func (s *UsersByEmail) IsAnalyzedValue() bool {
	return s.IsAnalyzed
}

func (s *UsersByEmail) IsBannedValue() bool {
	return s.IsBanned
}

func (s *UsersByEmail) IsConfirmedValue() bool {
	return s.IsConfirmed
}

func (s *UsersByEmail) IsEmployeeValue() bool {
	return s.IsEmployee
}

func (s *UsersByEmail) IsExpiringValue() bool {
	return s.IsExpiring
}

func (s *UsersByEmail) JwtEncryptionKeyValue() string {
	return s.JwtEncryptionKey
}

func (s *UsersByEmail) LastLoggedInValue() time.Time {
	return s.LastLoggedIn
}

func (s *UsersByEmail) RealNameValue() string {
	return s.RealName
}

func (s *UsersByEmail) TwitterNameValue() string {
	return s.TwitterName
}

func (s *UsersByEmail) UserRankValue() string {
	return s.UserRank
}

func (s *UsersByEmail) UserSelfDescriptionValue() string {
	return s.UserSelfDescription
}

func (s *UsersByEmail) UserTitleValue() string {
	return s.UserTitle
}

func (s *UsersByEmail) UserUnitValue() string {
	return s.UserUnit
}

type UsersByEmailDef struct {
	ACCESS_VALID_TILL cqlc.TimestampColumn

	ANALYTICS_USER_TRACKING_TOKEN cqlc.StringColumn

	EMAIL cqlc.LastPartitionedStringColumn

	ENCRYPTED_PASSWORD cqlc.StringColumn

	IS_ADMIN cqlc.BooleanColumn

	IS_ANALYZED cqlc.BooleanColumn

	IS_BANNED cqlc.BooleanColumn

	IS_CONFIRMED cqlc.BooleanColumn

	IS_EMPLOYEE cqlc.BooleanColumn

	IS_EXPIRING cqlc.BooleanColumn

	JWT_ENCRYPTION_KEY cqlc.StringColumn

	LAST_LOGGED_IN cqlc.TimestampColumn

	REAL_NAME cqlc.StringColumn

	TWITTER_NAME cqlc.StringColumn

	USER_RANK cqlc.StringColumn

	USER_SELF_DESCRIPTION cqlc.StringColumn

	USER_TITLE cqlc.StringColumn

	USER_UNIT cqlc.StringColumn
}

func BindUsersByEmail(iter *gocql.Iter) ([]UsersByEmail, error) {
	array := make([]UsersByEmail, 0)
	err := MapUsersByEmail(iter, func(t UsersByEmail) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapUsersByEmail(iter *gocql.Iter, callback func(t UsersByEmail) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := UsersByEmail{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "access_valid_till":
				row[i] = &t.AccessValidTill

			case "analytics_user_tracking_token":
				row[i] = &t.AnalyticsUserTrackingToken

			case "email":
				row[i] = &t.Email

			case "encrypted_password":
				row[i] = &t.EncryptedPassword

			case "is_admin":
				row[i] = &t.IsAdmin

			case "is_analyzed":
				row[i] = &t.IsAnalyzed

			case "is_banned":
				row[i] = &t.IsBanned

			case "is_confirmed":
				row[i] = &t.IsConfirmed

			case "is_employee":
				row[i] = &t.IsEmployee

			case "is_expiring":
				row[i] = &t.IsExpiring

			case "jwt_encryption_key":
				row[i] = &t.JwtEncryptionKey

			case "last_logged_in":
				row[i] = &t.LastLoggedIn

			case "real_name":
				row[i] = &t.RealName

			case "twitter_name":
				row[i] = &t.TwitterName

			case "user_rank":
				row[i] = &t.UserRank

			case "user_self_description":
				row[i] = &t.UserSelfDescription

			case "user_title":
				row[i] = &t.UserTitle

			case "user_unit":
				row[i] = &t.UserUnit

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *UsersByEmailDef) SupportsUpsert() bool {
	return true
}

func (s *UsersByEmailDef) TableName() string {
	return "users_by_email"
}

func (s *UsersByEmailDef) Keyspace() string {
	return "sitrep"
}

func (s *UsersByEmailDef) Bind(v UsersByEmail) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &UsersByEmailAccessValidTillColumn{}, Value: v.AccessValidTill},

		cqlc.ColumnBinding{Column: &UsersByEmailAnalyticsUserTrackingTokenColumn{}, Value: v.AnalyticsUserTrackingToken},

		cqlc.ColumnBinding{Column: &UsersByEmailEmailColumn{}, Value: v.Email},

		cqlc.ColumnBinding{Column: &UsersByEmailEncryptedPasswordColumn{}, Value: v.EncryptedPassword},

		cqlc.ColumnBinding{Column: &UsersByEmailIsAdminColumn{}, Value: v.IsAdmin},

		cqlc.ColumnBinding{Column: &UsersByEmailIsAnalyzedColumn{}, Value: v.IsAnalyzed},

		cqlc.ColumnBinding{Column: &UsersByEmailIsBannedColumn{}, Value: v.IsBanned},

		cqlc.ColumnBinding{Column: &UsersByEmailIsConfirmedColumn{}, Value: v.IsConfirmed},

		cqlc.ColumnBinding{Column: &UsersByEmailIsEmployeeColumn{}, Value: v.IsEmployee},

		cqlc.ColumnBinding{Column: &UsersByEmailIsExpiringColumn{}, Value: v.IsExpiring},

		cqlc.ColumnBinding{Column: &UsersByEmailJwtEncryptionKeyColumn{}, Value: v.JwtEncryptionKey},

		cqlc.ColumnBinding{Column: &UsersByEmailLastLoggedInColumn{}, Value: v.LastLoggedIn},

		cqlc.ColumnBinding{Column: &UsersByEmailRealNameColumn{}, Value: v.RealName},

		cqlc.ColumnBinding{Column: &UsersByEmailTwitterNameColumn{}, Value: v.TwitterName},

		cqlc.ColumnBinding{Column: &UsersByEmailUserRankColumn{}, Value: v.UserRank},

		cqlc.ColumnBinding{Column: &UsersByEmailUserSelfDescriptionColumn{}, Value: v.UserSelfDescription},

		cqlc.ColumnBinding{Column: &UsersByEmailUserTitleColumn{}, Value: v.UserTitle},

		cqlc.ColumnBinding{Column: &UsersByEmailUserUnitColumn{}, Value: v.UserUnit},
	}
	return cqlc.TableBinding{Table: &UsersByEmailDef{}, Columns: cols}
}

func (s *UsersByEmailDef) To(v *UsersByEmail) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &UsersByEmailAccessValidTillColumn{}, Value: &v.AccessValidTill},

		cqlc.ColumnBinding{Column: &UsersByEmailAnalyticsUserTrackingTokenColumn{}, Value: &v.AnalyticsUserTrackingToken},

		cqlc.ColumnBinding{Column: &UsersByEmailEmailColumn{}, Value: &v.Email},

		cqlc.ColumnBinding{Column: &UsersByEmailEncryptedPasswordColumn{}, Value: &v.EncryptedPassword},

		cqlc.ColumnBinding{Column: &UsersByEmailIsAdminColumn{}, Value: &v.IsAdmin},

		cqlc.ColumnBinding{Column: &UsersByEmailIsAnalyzedColumn{}, Value: &v.IsAnalyzed},

		cqlc.ColumnBinding{Column: &UsersByEmailIsBannedColumn{}, Value: &v.IsBanned},

		cqlc.ColumnBinding{Column: &UsersByEmailIsConfirmedColumn{}, Value: &v.IsConfirmed},

		cqlc.ColumnBinding{Column: &UsersByEmailIsEmployeeColumn{}, Value: &v.IsEmployee},

		cqlc.ColumnBinding{Column: &UsersByEmailIsExpiringColumn{}, Value: &v.IsExpiring},

		cqlc.ColumnBinding{Column: &UsersByEmailJwtEncryptionKeyColumn{}, Value: &v.JwtEncryptionKey},

		cqlc.ColumnBinding{Column: &UsersByEmailLastLoggedInColumn{}, Value: &v.LastLoggedIn},

		cqlc.ColumnBinding{Column: &UsersByEmailRealNameColumn{}, Value: &v.RealName},

		cqlc.ColumnBinding{Column: &UsersByEmailTwitterNameColumn{}, Value: &v.TwitterName},

		cqlc.ColumnBinding{Column: &UsersByEmailUserRankColumn{}, Value: &v.UserRank},

		cqlc.ColumnBinding{Column: &UsersByEmailUserSelfDescriptionColumn{}, Value: &v.UserSelfDescription},

		cqlc.ColumnBinding{Column: &UsersByEmailUserTitleColumn{}, Value: &v.UserTitle},

		cqlc.ColumnBinding{Column: &UsersByEmailUserUnitColumn{}, Value: &v.UserUnit},
	}
	return cqlc.TableBinding{Table: &UsersByEmailDef{}, Columns: cols}
}

func (s *UsersByEmailDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&UsersByEmailAccessValidTillColumn{},

		&UsersByEmailAnalyticsUserTrackingTokenColumn{},

		&UsersByEmailEmailColumn{},

		&UsersByEmailEncryptedPasswordColumn{},

		&UsersByEmailIsAdminColumn{},

		&UsersByEmailIsAnalyzedColumn{},

		&UsersByEmailIsBannedColumn{},

		&UsersByEmailIsConfirmedColumn{},

		&UsersByEmailIsEmployeeColumn{},

		&UsersByEmailIsExpiringColumn{},

		&UsersByEmailJwtEncryptionKeyColumn{},

		&UsersByEmailLastLoggedInColumn{},

		&UsersByEmailRealNameColumn{},

		&UsersByEmailTwitterNameColumn{},

		&UsersByEmailUserRankColumn{},

		&UsersByEmailUserSelfDescriptionColumn{},

		&UsersByEmailUserTitleColumn{},

		&UsersByEmailUserUnitColumn{},
	}
}

func UsersByEmailTableDef() *UsersByEmailDef {
	return &UsersByEmailDef{

		ACCESS_VALID_TILL: &UsersByEmailAccessValidTillColumn{},

		ANALYTICS_USER_TRACKING_TOKEN: &UsersByEmailAnalyticsUserTrackingTokenColumn{},

		EMAIL: &UsersByEmailEmailColumn{},

		ENCRYPTED_PASSWORD: &UsersByEmailEncryptedPasswordColumn{},

		IS_ADMIN: &UsersByEmailIsAdminColumn{},

		IS_ANALYZED: &UsersByEmailIsAnalyzedColumn{},

		IS_BANNED: &UsersByEmailIsBannedColumn{},

		IS_CONFIRMED: &UsersByEmailIsConfirmedColumn{},

		IS_EMPLOYEE: &UsersByEmailIsEmployeeColumn{},

		IS_EXPIRING: &UsersByEmailIsExpiringColumn{},

		JWT_ENCRYPTION_KEY: &UsersByEmailJwtEncryptionKeyColumn{},

		LAST_LOGGED_IN: &UsersByEmailLastLoggedInColumn{},

		REAL_NAME: &UsersByEmailRealNameColumn{},

		TWITTER_NAME: &UsersByEmailTwitterNameColumn{},

		USER_RANK: &UsersByEmailUserRankColumn{},

		USER_SELF_DESCRIPTION: &UsersByEmailUserSelfDescriptionColumn{},

		USER_TITLE: &UsersByEmailUserTitleColumn{},

		USER_UNIT: &UsersByEmailUserUnitColumn{},
	}
}

func (s *UsersByEmailDef) AccessValidTillColumn() cqlc.TimestampColumn {
	return &UsersByEmailAccessValidTillColumn{}
}

func (s *UsersByEmailDef) AnalyticsUserTrackingTokenColumn() cqlc.StringColumn {
	return &UsersByEmailAnalyticsUserTrackingTokenColumn{}
}

func (s *UsersByEmailDef) EmailColumn() cqlc.LastPartitionedStringColumn {
	return &UsersByEmailEmailColumn{}
}

func (s *UsersByEmailDef) EncryptedPasswordColumn() cqlc.StringColumn {
	return &UsersByEmailEncryptedPasswordColumn{}
}

func (s *UsersByEmailDef) IsAdminColumn() cqlc.BooleanColumn {
	return &UsersByEmailIsAdminColumn{}
}

func (s *UsersByEmailDef) IsAnalyzedColumn() cqlc.BooleanColumn {
	return &UsersByEmailIsAnalyzedColumn{}
}

func (s *UsersByEmailDef) IsBannedColumn() cqlc.BooleanColumn {
	return &UsersByEmailIsBannedColumn{}
}

func (s *UsersByEmailDef) IsConfirmedColumn() cqlc.BooleanColumn {
	return &UsersByEmailIsConfirmedColumn{}
}

func (s *UsersByEmailDef) IsEmployeeColumn() cqlc.BooleanColumn {
	return &UsersByEmailIsEmployeeColumn{}
}

func (s *UsersByEmailDef) IsExpiringColumn() cqlc.BooleanColumn {
	return &UsersByEmailIsExpiringColumn{}
}

func (s *UsersByEmailDef) JwtEncryptionKeyColumn() cqlc.StringColumn {
	return &UsersByEmailJwtEncryptionKeyColumn{}
}

func (s *UsersByEmailDef) LastLoggedInColumn() cqlc.TimestampColumn {
	return &UsersByEmailLastLoggedInColumn{}
}

func (s *UsersByEmailDef) RealNameColumn() cqlc.StringColumn {
	return &UsersByEmailRealNameColumn{}
}

func (s *UsersByEmailDef) TwitterNameColumn() cqlc.StringColumn {
	return &UsersByEmailTwitterNameColumn{}
}

func (s *UsersByEmailDef) UserRankColumn() cqlc.StringColumn {
	return &UsersByEmailUserRankColumn{}
}

func (s *UsersByEmailDef) UserSelfDescriptionColumn() cqlc.StringColumn {
	return &UsersByEmailUserSelfDescriptionColumn{}
}

func (s *UsersByEmailDef) UserTitleColumn() cqlc.StringColumn {
	return &UsersByEmailUserTitleColumn{}
}

func (s *UsersByEmailDef) UserUnitColumn() cqlc.StringColumn {
	return &UsersByEmailUserUnitColumn{}
}

type UsersByJwtEncryptionKeyColumn struct {
}

func (b *UsersByJwtEncryptionKeyColumn) ColumnName() string {
	return "encryption_key"
}

func (b *UsersByJwtEncryptionKeyColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByJwtJwtColumn struct {
}

func (b *UsersByJwtJwtColumn) ColumnName() string {
	return "jwt"
}

func (b *UsersByJwtJwtColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *UsersByJwtJwtColumn) Eq(value string) cqlc.Condition {
	column := &UsersByJwtJwtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *UsersByJwtJwtColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *UsersByJwtJwtColumn) In(value ...string) cqlc.Condition {
	column := &UsersByJwtJwtColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type UsersByJwtUserEmailColumn struct {
}

func (b *UsersByJwtUserEmailColumn) ColumnName() string {
	return "user_email"
}

func (b *UsersByJwtUserEmailColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByJwtUserNameColumn struct {
}

func (b *UsersByJwtUserNameColumn) ColumnName() string {
	return "user_name"
}

func (b *UsersByJwtUserNameColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type UsersByJwt struct {
	EncryptionKey string

	Jwt string

	UserEmail string

	UserName string
}

func (s *UsersByJwt) EncryptionKeyValue() string {
	return s.EncryptionKey
}

func (s *UsersByJwt) JwtValue() string {
	return s.Jwt
}

func (s *UsersByJwt) UserEmailValue() string {
	return s.UserEmail
}

func (s *UsersByJwt) UserNameValue() string {
	return s.UserName
}

type UsersByJwtDef struct {
	ENCRYPTION_KEY cqlc.StringColumn

	JWT cqlc.LastPartitionedStringColumn

	USER_EMAIL cqlc.StringColumn

	USER_NAME cqlc.StringColumn
}

func BindUsersByJwt(iter *gocql.Iter) ([]UsersByJwt, error) {
	array := make([]UsersByJwt, 0)
	err := MapUsersByJwt(iter, func(t UsersByJwt) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapUsersByJwt(iter *gocql.Iter, callback func(t UsersByJwt) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := UsersByJwt{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "encryption_key":
				row[i] = &t.EncryptionKey

			case "jwt":
				row[i] = &t.Jwt

			case "user_email":
				row[i] = &t.UserEmail

			case "user_name":
				row[i] = &t.UserName

			default:
				log.Fatal("unhandled column: ", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *UsersByJwtDef) SupportsUpsert() bool {
	return true
}

func (s *UsersByJwtDef) TableName() string {
	return "users_by_jwt"
}

func (s *UsersByJwtDef) Keyspace() string {
	return "sitrep"
}

func (s *UsersByJwtDef) Bind(v UsersByJwt) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &UsersByJwtEncryptionKeyColumn{}, Value: v.EncryptionKey},

		cqlc.ColumnBinding{Column: &UsersByJwtJwtColumn{}, Value: v.Jwt},

		cqlc.ColumnBinding{Column: &UsersByJwtUserEmailColumn{}, Value: v.UserEmail},

		cqlc.ColumnBinding{Column: &UsersByJwtUserNameColumn{}, Value: v.UserName},
	}
	return cqlc.TableBinding{Table: &UsersByJwtDef{}, Columns: cols}
}

func (s *UsersByJwtDef) To(v *UsersByJwt) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		cqlc.ColumnBinding{Column: &UsersByJwtEncryptionKeyColumn{}, Value: &v.EncryptionKey},

		cqlc.ColumnBinding{Column: &UsersByJwtJwtColumn{}, Value: &v.Jwt},

		cqlc.ColumnBinding{Column: &UsersByJwtUserEmailColumn{}, Value: &v.UserEmail},

		cqlc.ColumnBinding{Column: &UsersByJwtUserNameColumn{}, Value: &v.UserName},
	}
	return cqlc.TableBinding{Table: &UsersByJwtDef{}, Columns: cols}
}

func (s *UsersByJwtDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&UsersByJwtEncryptionKeyColumn{},

		&UsersByJwtJwtColumn{},

		&UsersByJwtUserEmailColumn{},

		&UsersByJwtUserNameColumn{},
	}
}

func UsersByJwtTableDef() *UsersByJwtDef {
	return &UsersByJwtDef{

		ENCRYPTION_KEY: &UsersByJwtEncryptionKeyColumn{},

		JWT: &UsersByJwtJwtColumn{},

		USER_EMAIL: &UsersByJwtUserEmailColumn{},

		USER_NAME: &UsersByJwtUserNameColumn{},
	}
}

func (s *UsersByJwtDef) EncryptionKeyColumn() cqlc.StringColumn {
	return &UsersByJwtEncryptionKeyColumn{}
}

func (s *UsersByJwtDef) JwtColumn() cqlc.LastPartitionedStringColumn {
	return &UsersByJwtJwtColumn{}
}

func (s *UsersByJwtDef) UserEmailColumn() cqlc.StringColumn {
	return &UsersByJwtUserEmailColumn{}
}

func (s *UsersByJwtDef) UserNameColumn() cqlc.StringColumn {
	return &UsersByJwtUserNameColumn{}
}
